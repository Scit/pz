\ESKDdocName{Технология автоматизированной сборки и развертывания проектов}
\updateStamp
\ESKDthisStyle{formII}
\section{Технология автоматизированной сборки и развертывания проектов с использованием фреймворка Maven}
\subsection{Концепция автоматизированной сборки программного обеспечения}
Непрерывные процессы усложнения программного обеспечения, сред и средств разработки, взаимной интеграции и использования составных частей различных технологий и приложений в одном проекте, использование методологий гибкой разработки ПО~--- зачастую делают традиционный подход к процессу ручной сборки программного обеспечения неоправнанно трудозатратным и малоэффективным.

Использование в процессе разработки систем управления версиями, таких как Git или CVS, на сегодняшний день является общепринятой практикой. Когда над одной системой работает большое число разработчиков, такая координация становится необходимой.  При этом важно быть уверенным, что последняя версия кода, находящаяся в системе управления версиями, всегда успешно собирается. Это хороший метод для проектов с замкнутыми командами разработчиков; когда разработчики периодически синхронизируют свои рабочие области с транком, несобирающийся исходный код задержит процесс разработки до исправления проблемы. Для проектов же с открытым исходным кодом сохранение основной ветки разработки в рабочем состоянии просто жизненно необходимо. Потенциальные программисты могут загрузить код в любой момент, и если он окажется в нерабочем состоянии~--- это с большой делей вероятности оттолкнет их от дальнейшего участия в таком проекте.

Другим современным аспектом разработки является подход, ориентированный на написание модульных тестов и включение их в выполнение на этапе сборки.
	Актуальная сегодня методология "экстремального программирования" (англ. Extreme Programming, XP) предполагает процесс непрерывной интеграции. Разработчики интегрируют свой код в основную ветку разработки как можно чаще~--- как правило, раз в несколько часов~--- проверяя при этом успешное выполнение всех тестов. Аналогичные методики итеративной разработки ПО придерживаются подобного подхода.

Для адаптации непрерывной интеграции и модульного тестирования необходимо, чтобы разработка проекта следовала этим методикам. Однако, зачастую этого недостаточно.

Итак, поскульку вышезложенные методы подходы состоят из неавтоматизированных шагов~--- интеграции кода, выполнения тестов и постоянном внесении кода в репозиторий~--- все это может повлечь технические трудности, излишние временные затраты и ошибки. Автоматизированная система, собирающая код и выполняющая модульные тесты, является гораздо более надежным решением.

\subsubsection{Требования к системам автоматизированной сборки ПО}
Базовые требования:
\begin{enumerate}
\item частые или <<ночные>> сборки для своевременного выявления проблем;
\item поддержка управления зависимостями исходного кода (Source Code Dependency Management);
\item обработка разностной сборки;
\item уведомление при совпадении исходного кода (после сборки) с имеющимися бинарными файлами;
\item ускорение сборки;
\item отчет о результатах компиляции и линковки.
\end{enumerate}

Дополнительные требования:
\begin{enumerate}
\item создание описания изменений (release notes) и другой сопутствующей документации (например, руководства);
\item отчет о статусе сборки;
\item отчет об успешном/неуспешном прохождении тестов;
\item суммирование добавленных/измененных/удаленных особенностей в каждой новой сборке.
\end{enumerate}

\subsubsection{Преимущества использования}
\begin{itemize}
\item улучшение качества продукта;
\item ускорение процесса компиляции и линковки;
\item избавление от излишних действий;
\item минимизация некорректных сборок;
\item избавление от привязки к конкретному человеку;
\item ведение истории сборок и релизов для разбора выпусков;
\item экономия времени и денег благодаря вышеобозначенных причинам,
\end{itemize}

\subsection{Система автоматизированной сборки Maven}
Apache Maven~--- фреймворк для автоматизации сборки проектов, специфицированных на XML-подобном языке POM (англ. Project Object Model). Maven обеспечивает декларативную сборку проекта. Это означает, что в файлах проекта pom.xml содержится его декларативное описание, а не отдельные команды. Все задачи по обработке файлов Maven выполняет через плагины.

\subsubsection{Преимущества Maven}
\begin{itemize}
\item независимость от OS. Сборка проекта происходит в любой операционной системе. При этом сборочный файл проекта остается неизменным от системы к системе;
\item управление зависимостями. Подавляющее большинство проектов пишутся с использованием сторонних библиотек (зависимостей). Эти сторонние библиотеки зачастую тоже используют другие библиотеки в качестве зависимостей. Maven позволяет управлять такими сложными процессами.  Это позволяет осуществлять поиск и установку нужного ПО, разрешать конфликты версий и, в случае необходимости, легко переходить на новые версии библиотек;
\item возможность сборки из командной строки. Такое часто необходимо для автоматической сборки проекта на сервере (практика использования подхода Continuous Integration);
\item хорошая интеграция со средами разработки. Основные среды разработки на Java без каких-либо сложностей поддерживают проекты, которые собираются c помощью фреймворка maven. При этом, зачастую, даже не требуется дополнительная настойка проекта~--- он сразу готов к дальнейшей разработке. Как следствие~--- если с проектом работают в разных средах разработки, то maven является отличным средством по унифицикации способа хранения настроек. Настроечный файл среды разработки и для сборки один и тот же~--- это уменьшает дублирование данных и, соответственно, количество ошибок;
\item декларативный стиль описания проекта. Позволяет лучшим образом формулировать конечные цели по организации проекта, не вдаваясь в детали и способы их реализации.
\end{itemize}

\subsubsection{Создание проекта под управлением maven}
Данные и последующие действия предполагают наличие установленного в системе фреймворка maven.

Для создания нового проекта необходимо ввети следующую команду:
\begin{lstlisting}
mvn archetype:generate
\end{lstlisting}
 
	Выполнив эту команду, maven покажет список шаблонов (архетипов) для разных проектов. Необходимо выбрать проект и его версию по умолчанию, Далее команда спросит groupId и artifactId.
В результате сгенерируется проект со стандартной структурой директорий:
\begin{lstlisting}
testproject1
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `--ru
    |           `-- ru.apache_maven
    |                   `-- App.java
    `-- test
        `-- java
            `-- ru
                `-- ru.apache_maven
                        `-- AppTest.java
\end{lstlisting}
        
В примере генерируется настройки приложения, включающего в себя помимо исходного кода набор JUnit-тестов и pom.xml~--- основной настроечный файл maven, который будет рассмотрен в следующем подразделе.

Чтобы скомпилировать код, нужно набрать в консоли: mvn compile. Успешная сборка проекта сопровождается следующим сообщением:

\begin{lstlisting}
.....
[INFO] BUILD SUCCESS
.....
\end{lstlisting}

Ввод команды “mvn package” в директории target сгенерирует jar файл testproject1-1.0-SNAPSHOT.jar.

\subsubsection{Основной файл проекта pom.xml}
pom.xml~--- это основной файл, описывающий проект. Вообще, в проекте могут использоваться дополнительные файлы, однако они играют второстепенную роль. Рассмотрим структуру файла pom.xml.

Корневой элемент и заголовок.

\begin{lstlisting}
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                    http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    .............
</project>
\end{lstlisting}

Здесь находится корневой элемент <project>, схема, которая облегчает редактирование и проверку, и версия POM.Внутри тэга project содержится основная и обязательная информация о проекте:

\begin{lstlisting}
<!-- The Basics -->
  <groupId>...</groupId>
  <artifactId>...</artifactId>
  <version>...</version>
\end{lstlisting}

В Maven каждый проект идентифицируется парой groupId artifactId. Во избежание конфликта имен, в groupId заносится наименование организации или подразделения и обычно действуют такие же правила как и при именовании пакетов в Java~--- записывают доменное имя организации или сайта проекта. artifactId~--- название проекта. Внутри тэга version, как можно догадаться хранится версия проекта. Тройкой groupId, artifactId, version (далее~--- GAV) можно однозначно идентифицировать jar файл приложения или библиотеки. Если состояние кода для проекта не зафиксировано, то в конце к имени версии добавляется \"-SNAPSHOT\", что обозначает, что версия в разработке, и результирующий jar файл может меняться. <packaging>...</packaging> определяет какого типа файл будет создаваться как результат сборки. Возможные варианты pom, jar, war, ear.

Также добавляется информация, которая не используется самим мавеном, но нужна для программиста, чтобы понять, о чем этот проект:
\begin{itemize}
\item<name>powermock-core</name>~--- название проекта для человека;
\item<description>PowerMock core functionality.</description>~--- описание проекта;
\item<url>http://www.powermock.org</url>~--- сайт проекта.
\end{itemize}

\subsubsection{Зависимости}
Зависимости~--- следующая очень важная часть pom.xml~--- в данной секции хранится список всех библиотек (зависимостей) которые используюся в проекте. Каждая библиотека идентифицируется также как и сам проект~--- тройкой groupId, artifactId, version (GAV). Объявление зависимостей заключено в тэг <dependencies>...</dependencies>.

\begin{lstlisting}
<dependencies>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.4</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-reflect</artifactId>
    <version>\${version}</version>
</dependency>
<dependency>
    <groupId>org.javassist</groupId>
    <artifactId>javassist</artifactId>
    <version>3.13.0-GA</version>
    <scope>compile</scope>
</dependency>
</dependencies>
\end{lstlisting}

Как можно заметить, кроме GAV при описании зависимости может присутствовать тэг <scope>. Scope задает спецификацию назначения данной библиотеки. В рассматриваемом примере указывается, что библиотека с GAV junit:junit:4.4 нужна только для выполнения тестов.

\subsubsection{Тэг <<build>>}
Тэг <build> является необязательным т.к. для него существуют значения по умолчанию. Этот раздел содержит информацию по самой сборке: где находятся исходные файлы, ресурсы проекта, список используемых плагинов.

\begin{lstlisting}
<build>
<outputDirectory>target2</outputDirectory>
<finalName>ROOT</finalName>
<sourceDirectory>src/java</sourceDirectory>
<resources>
    <resource>
        <directory>\${basedir}/src/java</directory>
        <includes>
        <include>**/*.properties</include>
        </includes>
    </resource>
</resources>
     <plugins>
         <plugin>
             <groupId>org.apache.maven.plugins</groupId>
             <artifactId>maven-pmd-plugin</artifactId>
             <version>2.4</version>
         </plugin>
     </plugins>
 </build>
\end{lstlisting}

Рассмотрим содержимое <build> секции.

\begin{itemize}
\item <sourceDirectory>~--- определяет, откуда maven будет брать файлы исходного кода. По умолчанию это src/main/java, но можно самостоятельно определить путь к исходному тексту. Директория может быть только одна (без использования специальных плагинов).
\item <resources> и вложенные в нее тэги <resource> определяют одну или несколько директорий, где хранятся файлы ресурсов. Ресурсы в отличии от файлов исходного кода при сборке просто копируются. Директория по умолчанию: src/main/resources 
\item <outputDirectory>~--- определяет, в какую директорию компилятор будут сохраняться результаты компиляции~--- *.class файлы. Значение по умолчанию: target/classes.
\item <finalName>~--- имя результирующего jar (war, ear..) файла с соответствующим типу расширением, который создается на фазе “package”. Значение по умолчанию: artifactId-version.
\end{itemize}

\subsubsection{Основные фазы сборки проекта}
\begin{itemize}
\item compile~--- компилирование проекта;
\item test~--- тестирование с помощью JUnit тестов;
\item package~--- создание .jar файла или war, ear в зависимости от типа проекта;
\item integration-test~--- запуск интеграционных тестов;
\item install~--- копирование .jar (war , ear) в локальный репозиторий;
\item deploy~--- публикация файла в удаленный репозиторий.
\end{itemize}

К примеру нам нужно создать jar проекта. Для его создания необходимо набрать:
\begin{lstlisting}
mvn package
\end{lstlisting}

Но перед тем как создаться jar файл будут выполняться все предыдущие фазы compile и test, а фазы integration-test, install, deploy не выполнятся. Если набрать:

\begin{lstlisting}
mvn deploy
\end{lstlisting}

то выполнятся все приведенные выше фазы.

Особым образом стоят фазы clean и site. Они не выполняются если специально не указаны в строке запуска.

\begin{itemize}
\item clean~--- удаление всех созданных в процессе сборки артефактов: .class, .jar и др. файлов. В простейшем случае результат~--- просто удаление каталога target;
\item site~--- предназначена для создания документации (javadoc + сайт описания проекта).
\end{itemize}

Т.к. команда mvn понимает когда ему передают несколько фаз, то для первоначальной сборки проекта и создания документации выполняют:

\begin{lstlisting}
mvn clean package site
\end{lstlisting}

\subsubsection{Будущее автоматизированных систем сборки проектов}
Вслед за появлением распределенных вычислительных систем обработки данных приходит время и нового поколения распределенных систем сборки проектов.  Термин <<распределенные сборки>> подразумевает, что вызовы компилятора и линковщика могут передаваться множеству компьютеров для ускорения скорости сборки.

Распределенный процесс сборки должен обладать определенной логикой, чтобы правильно определить зависимости в исходном коде для того чтобы выполнить этапы компиляции и линковки на разных машинах. Решение автоматизации сборки должно быть способно управлять этими зависимостями, чтобы выполнять распределенные сборки. Некоторые инструменты сборки могут распознавать подобные взаимосвязи автоматически (Rational ClearMake distributed, Electric Cloud ElectricAccelerator), а другие зависят от пользовательских указаний (Platform LSF lsmake) Автоматизация сборки, способная рассортировывать взаимосвязи зависимостей исходного кода, также может быть настроена на выполнение действий компиляции и линковки в режиме параллельного выполнения. Это означает, что компиляторы и линковщики могут быть вызваны в многопоточном режиме на машине, сконфигурированной с учетом наличия более одного процессорного ядра.

Далеко не все инструменты автоматизации сборки могут выполнять распределенные сборки. Большинство из них лишь реализует поддержку распределенной обработки (что далеко не то же самое). Кроме того, большинство решений, поддерживающих распределенные сборки, могут лишь обрабатывать код на языках Си и C++. Решения автоматизации сборки, поддерживающие распределенную обработку, зачастую основаны на Make и не поддерживают Maven или Ant.

В качестве примера решения распределенной сборки можно привести систему Xoreax’s IncrediBuild для платформы Microsoft Visual Studio. Это может потребовать специфической настройки программного окружения чтобы успешно функционировать на распределенной платформе (нужно указать расположение библиотек, переменные окружения и т. д.).

Из этого видно, что подход автоматизировнной сборки программного обеспечения является достаточно сложной и развитой технологией, позволяющей уже сегодня автоматизировать большую часть ручной работы по созданию целых систем и комплектов из наборов сложных стуртур изходных кодов, реусурсов, внешних зависимостей, библиотек и других компонентов проектов, обещая в ближайшем будущем сделать эти процессы еще более эффективными и технологичными, используя для этого уже описанные ранее преимущества концепции распределенных вычислений.
