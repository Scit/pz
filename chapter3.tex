\section{Описание и разработка распределенной системы доступа к базам данных на основе программных агентов платформы JADE}
\subsection{Краткое описание разрабатываемой системы}
Описываемая распределенная система разрабатывалась на объектно-ориентированном языке программирования Java. Ядром системы является программная платформа JADE, включающая в себя как набор классов для реализации агентно-ориентированных приложений, так и инструментарий для запуска, управления и настройки платформ, контейнеров и агентов.

	Для хранения данных используется свободная объектно-ориентированная система управления базами данных Postgresql. В качестве библиотеки с базой используется jdbc-драйвер. Взаимодействие системы с пользователем осуществляется с помощью стандартного графического оконного интерфейса на основе средств, представляемых библиотекой Swing.

	Управление процессом разработки осуществляется с помощью системы контроля версий GIT. Это позволяет контролировать все изменения в проекте, фиксировать контрольные точки и этапы разработки, а также мгновенно переключаться между ними. Исходный код проекта синхронизируется с сервером github.com. Это позволяет иметь доступ к проекту из любого места, где есть доступ к сети интернет.

	Сборка проекта, поиск и установка зависимостей осущестляется с помощью фреймворка Maven. Это позволяет в значительной мере сократить сроки и усилия по развертыванию, переносу, изменению конфигурации проекта и другим подобным операциям.

	Проектируемая распределенная система будет состоять из наборов взаимодействующих между собой программных агентов, часть из которых будет находиться на локальном контейнере платформы и обрабатывать пользовательские  запросы к базе, а часть~--- на удаленных контейнерах, имеющих в своем составе сервер базы данных, отвечая за обработку запросов от локальных агентов-клиентов, передачу этих запросов в СУБД, обработку и передачу ответа. Пользователь, взаимодействуя с графическим интерфейсом, будет формировать запросы, отправляемые первоначально на агент-контроллер, отвечающий за логику  межагентного взаимодействия, и получать ответы от удаленных серверов в главном окне программы.
\begin{figure}[h]
\center{\includegraphics[width=0.9\linewidth]{common-scheme}}
\caption{Общая структура разрабатываемого приложения}
\label{3:common-scheme}
\end{figure}
Кроме этого, следует отметить, что изначально система запускается на локальном контейнере, а затем с помощью технологии мобильных агентов перемещает агенты-сервисы на имеющиеся в составе платформы удаленные контейнеры. Это позволяет иметь полную независимость от конфигураций серверных машин, версий и взаимной совместимости сервисной части системы на каждом удаленном узле. Более того, не потребуется помощь технического специалиста по настройке системы на каждом узле, не потребуется помощь и при масштабировании системы. Приложению достаточно увидеть новый контейнер в составе системы (ествественно, имеющей в своем составе необходимые для функционирования системы зависимости: JADE-платформа, без которой в общем-то и невозможно взаимное обнаружение и взаимодействие контейнеров внутри платформы, СУБД postgresql и т.д.), после чего, по указанию пользователя, будет произведена загрузка агента-сервиса на удаленный контейнер и его дальнейшее функционирование в рамках распределенной системы.

	Ниже приведена диаграмма последовательности запуска приложения и добавления нового узла (контейнера) в состав распределенной системы. Подобная последовательность событий и действий является аналогичной (начиная с события регистрации нового контейнера) при добавлении новых узлов в состав системы.
\begin{figure}[h]
\center{\includegraphics[width=0.9\linewidth]{seq-launch}}
\caption{Диаграмма последовательности запуска приложения и добавления нового узла}
\label{3:seq-launch}
\end{figure}
После загрузки агента-сервиса на удаленный контейнер происходит уведомление агента-контроллера, расположенного в составе модуля управления и  межагентного взаимодействия, после чего для агента-сервиса создается агент-клиент, который впоследствии будет уже напрямую обращаться к данному сервису.

Выбирая активные платформы, пользователь может обмениваться с ними информацией, не заботясь об их конфигурациях и местоположении.

Из доступных операций пользователю предоставляется возможность:
\begin{itemize}
\item получать список таблиц, расположенных на удаленном контейнере;
\item отображать контент выбранной таблицы контейнера;
\item редактировать данные выбранной таблицы;
\item добавлять данные в выбранную таблицу;
\item добавлять данные в выбранную таблицу с автоматическим реплицированием на активные контейнеры при наличии на них этой же таблицы;
\item выполнять RAWSQL-запросы на выбранный контейнер;
\item выполнять RAWSQL-запросы на все активные контейнеры.
\end{itemize}

\subsection{Описание состава пакетов системы}
\subsubsection{Состав пакета client}
Данный пакет содержит классы, входящие в состав агента-клиента. Основной класс ClientAgent, как видно из названия, реализует логику работы самого агента.

\paragraph{Класс ClientAgent}
Класс агента, как правило реализует основной метод setup(), в котором происходит инициализация агента, добавление поведений и другие операции, связанные с функционированием агента.
Ниже показано содержимое метода setup() класса ClientAgent:
\begin{verbatim}
protected void setup() {
    setEnabledO2ACommunication(true, 0);
    Object[] args = getArguments();

    switch(args.length) {
        case 3:
            serviceAID = (AID) args[2];
        case 2:
            agentInterface = (AgentInterface) args[1];
        case 1:
            ConditionalVariable startUpLatch = (ConditionalVariable) args[0];
            startUpLatch.signal();
    }

    ((AgentEvents) agentInterface).onEvent(new AID(getName(), AID.ISLOCALNAME), AgentEvents.EVENT_CLIENT_READY);
    addBehaviour(new O2ABehaviour());
}
\end{verbatim}
По-сути, содержимое метода отвечает за настройку приема данных от внешних классов, не являющихся агентами. Это реализовано с помощью технологии Object2Agent communication. Для этого необходимо включить поддержку взаимодействия O2A методом setEnabledO2ACommunication().

Далее, в контрукции switch() происходит выборка доступных аргументов, с которыми был запущен агент.

Первым аргументом (порядок аргументов идет с конца) передается мьютекс ConditionalVariable, который позволяет внешнему окружению дождаться запуска и инициализации агента. В противном случае, данные агентом получены не будут.

Второй аргумент хранит подписчика на события агента. Интерфейс AgentInterface имеет два интерфейса-потомка: AgentData и AgentEvents. Первый из них отвечает за уведомление о поступающих от агента данных, а второй~--- о возникающих событиях. В данном случае, агент посылает событие EVENT\_CLIENT\_READY, означающее готовность агента к функционированию.

Третий аргумент хранит AID~--- идентификатор~--- агента-сервиса, за которым <<закреплен>> данный агент-клиент.

В конце метода происходит добавление поведения O2ABehaviour, которое обрабатывает входящие данные от внешних модулей приложения.

\paragraph{Класс ClientBehaviour}
Основным методом объектов класса Behaviour является метод action(). Данный метод вызывается платформой по правилам, заложенным в реализации класса.

\begin{verbatim}
public void action() {
    ACLMessage message = null;

    switch (state) {
        case SENDING:
            message = new ACLMessage(ACLMessage.REQUEST);
            message.addReceiver(aid);

            try {
                message.setContentObject(agentDataContainer);
            } catch (IOException e) {
                e.printStackTrace();
            }

            myAgent.send(message);
            state++;
            break;
        case RECEIVING:
            message = myAgent.receive();
            if(message != null) {
                try {
                    agentDataContainer = (AgentDataContainer) message.getContentObject();
                } catch (UnreadableException e) {
                    e.printStackTrace();
                }

                AgentData agentData = (AgentData) ((ClientAgent) myAgent).getAgentInterface();
                AID aid = new AID(myAgent.getName(), AID.ISLOCALNAME);
                agentData.onData(aid, agentDataContainer);
                done = true;
            } else {
                block();
            }

            break;
    }
}
\end{verbatim}
Функционирование основного поведения агента-клиента реализовано в виде <<машины состояний>>. На первом этапе поведение функционирует в состоянии отправки запроса агенту сервиса, для чего формируется соотвестствующее ACL сообщение. На втором~--- в ожидании ответа от сервиса. В конце выполнения поведения происходит уведомление агента о полученных данных от агента-сервиса.

\paragraph{Класс O2ABehaviour}
Класс O2ABehaviour содержит циклический опрос очереди O2A-сообщений. При отсутствии сообщений поведение блокируется методом block() до появления нового сообщения в очереди.
\begin{verbatim}
public void action() {
    AgentDataContainer agentDataContainer = (AgentDataContainer) myAgent.getO2AObject();
    if(agentDataContainer != null) {
        myAgent.addBehaviour(new ClientBehaviour(myAgent, agentDataContainer));
    } else {
        block();
    }
}
\end{verbatim}

\subsubsection{Состав пакета service}
\paragraph{Класс ServiceAgent}
Основной класс пакета service~--- ServiceAgent. Его метод setup() аналогичен содержимому метода класса ClientAgent. Помимо этого, класс ServiceAgent реализует методы beforeMove() и afterMove()~--- это callback-методы, вызываемые платформой JADE, соотвественно до и после операции перемещения агента. Метод beforeMove() не содержит функциональной логики, а служит лишь для печати отладочной информации на консоль. Метод afterMove() добавляет новое поведение в состав агента, и посылает сообщение агенту-контроллеру о своем перемещении.
\begin{verbatim}
protected void afterMove() {
    addBehaviour(new ServiceBehaviour(this));

    System.out.println("After move: " + here());
    ACLMessage msg = new ACLMessage(ACLMessage.INFORM);
    msg.setConversationId(ControllerAgent.CONTROLLER_AGENT_CONVERSATION_ID);
    AID dest = new AID(ContainerHoldersManager.CONTROLLER_AGENT_NAME, AID.ISLOCALNAME);
    msg.setContent(getName());
    try {
        msg.setContentObject(here());
    } catch (IOException e) {
        e.printStackTrace();
    }
    msg.addReceiver(dest);
    send(msg);
}
\end{verbatim}
\paragraph{Класс ServiceAgent}
Поведение агента-сервиса ServiceBehaviour содержит интерфейсы взаимодействия с базой данных узла посредством классов, предоставляемых пакетом db. Логически поведение разбито на две части: это обработка запроса с передачей его к СУБД и формирование и отправка ответа агенту-клиенту. Кроме этого, при получении сообщения с типом CANCEL сервис завершает свою работу.
\begin{verbatim}
public void action() {
    ACLMessage msg = myAgent.receive();
    if (msg != null) {
        switch (msg.getPerformative()) {
            case ACLMessage.REQUEST:
                ACLMessage reply = msg.createReply();
                reply.setPerformative(ACLMessage.INFORM);
                AgentDataContainer agentDataContainer = null;

                try {
                    agentDataContainer = (AgentDataContainer) msg.getContentObject();
                    System.out.print(agentDataContainer);
                } catch (UnreadableException e) {
                    e.printStackTrace();
                }

                agentDataContainer = dbw.execute(agentDataContainer);
                agentDataContainer.setParam(AgentDataContainer.KEY_CONTAINER_NAME, myAgent.here().getName());

                try {
                    reply.setContentObject(agentDataContainer);
                } catch (IOException e) {
                    e.printStackTrace();
                }

                myAgent.send(reply);
                break;
            case ACLMessage.CANCEL:
                myAgent.doDelete();
                break;
        }
    } else {
        block();
    }
}
\end{verbatim}

\subsubsection{Состав пакета ctrl}
Пакет ctrl включает в себя классы, осуществляющие организацию межагентного взаимодействия, управление контейнерами, входящими в состав платформы, уведомление внешних внеагентных компонентов о событиях внутри платформы.
\paragraph{Класс ControllerAgent}
Запускает поведение мониторинка контейнеров платформы.

Уведомляет основной программный контроллер ContainerHolderManager о процедуре перемещения агентов-сервисов.

\paragraph{Класс AMSListenerBahaviour}
Данное поведение регистрирует обработчик в плтаформе JADE. Внутри обработчика добавления новых контейнеров просходит получение идентификатора контейнера и передача его контроллеру приложения.
\begin{verbatim}
public class AMSListenerBehaviour extends AMSSubscriber {
    public void installHandlers(Map handlersTable) {
        handlersTable.put(AddedContainer.NAME, new AddedContainerHandler());
    }

    public final class AddedContainerHandler implements EventHandler {
        public void handle(Event ev) {
            AddedContainer event = (AddedContainer) ev;
            ContainerID addedContainer = event.getContainer();

            ContainerHoldersManager.onContainerAdded(addedContainer);
        }
    }
}
\end{verbatim}

\paragraph{Класс ContainerHolder}
Данный класс хранит всю информацию, относящующся к конкретному контейнеру, а также предоставляет все интерфейсы для взаимодействия агентов клиента и сервиса внешним компонентам приложения. Основые поля класса:

\begin{itemize}
\item AgentController client~--- агент-клиент, относящийся к данному контейнеру;
\item AID serviceID~--- идентификатор сервиса, который расположен на данному конейнеру;
\item ContainerID containerID~--- идентификатор контейнера;
\item isActive~--- флаг активности контейнера~--- активный контейнер имеет в своем составе запущенные агенты сервиса и клиента, относящиеся к данному контейнеру.
\end{itemize}

\begin{itemize}
\item doActivate()~--- активирует данный контейнер;
\item doExecute()~--- отправляет запрос на сервис. В качестве параметра передается объект класса AgentDataContainer;
\item onData()~--- callback-функция получения информации от сервиса;
\item onEvent()~--- callback-функция получения событий от сервиса.
\end{itemize}

\paragraph{Класс ContainerHoldersManager}
Класс ContainerHoldersManager служит для взаимодействия
